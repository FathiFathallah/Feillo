package Chat_Application;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTextPane;
import javax.swing.text.AttributeSet;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import jbuf.Packet;



public class ClientChat_App extends javax.swing.JFrame {

    static final int HEADER_LENGTH = (int) (1 + 1 + 1 + 4 + 4 + 4);
    static final int MAX_DATA_LENGTH = 1024;
    static final String CRC_16 = "11000000000000101";
    
    private String ClientUsername;
    private boolean LoggedIn = false;
    private InetAddress SrcIpAddress,DestIpAddress;
    private int DestPortNumber;
    private int SrcPortNumber = 70000;
    
    private byte[] sendData; 
    private byte[] receiveData = new byte[ HEADER_LENGTH + MAX_DATA_LENGTH ];
    private DatagramSocket clientSocket;
    private ReceivingThread myThread;
    private boolean thread_on = false;
    private OnlineUsersThread onlineUsersThread;
    private boolean users_thread_on = false;


    private String TCP_String;
    private InetAddress TCP_IPAddress; 
    private int TCP_PortNumber;
    private Socket ClientTCPSocket;
    private DataOutputStream outToServer;
    private InputStreamReader Reader;
    private BufferedReader inFromServer;
    
    private DefaultListModel USERSLIST;
    private DefaultListModel FILESLIST;
    private String ClientInfoDelete;
    private JFileChooser fileChooser;
    private File selectedFile = null;
    
    private ArrayList<MyFile> AllFiles;
    private int FileArrayListIndex = 0;
    
    private ArrayList<MyFile> SentFiles;
    private int FileSentIndex=0;
    private int FileSentID = 1;
    private JFileChooser DIRECTORYChooser;
    
    private Animation animationThread;
    private boolean startAnimation = false;
    private SendButtonAnimation sendanimation;
    private boolean startSendAnimation = false;
    private boolean Sending = false;
    
    private Random generator;
    /**
     * Creates new form ClientChat_App
     */
    
    public ClientChat_App() {
        initComponents(); 
        
        try {
            InetAddress inetAddress = InetAddress.getLocalHost();
            this.AvailableInterfaces.addItem(inetAddress.getHostName() +": " + inetAddress.getHostAddress());
        } catch (UnknownHostException ex) {
            Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
        } 
        myThread = new ReceivingThread("RECEIVER");
        myThread.start();
        this.onlineUsers.setForeground(new Color(0,153,51));
        this.USERSLIST = new DefaultListModel();
        this.onlineUsers.setModel(USERSLIST);
        
        
        this.FILESLIST = new DefaultListModel();
        this.Files.setModel(FILESLIST);
        
        AllFiles = new ArrayList<MyFile>();
        SentFiles = new ArrayList<MyFile>();
        
        fileChooser = new JFileChooser();
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        if (fileChooser.isMultiSelectionEnabled()) {
            fileChooser.setMultiSelectionEnabled(false);
        }
        fileChooser.setCurrentDirectory(new File(System.getProperty("user.home")));
        
        
        DIRECTORYChooser = new JFileChooser();
        DIRECTORYChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        
        animationThread = new Animation("ANIMATION");
        animationThread.start();
        sendanimation = new SendButtonAnimation("SENDANIMATION");
        sendanimation.start();
        
        this.generator = new Random();
        this.RetransmissionsAndError.setText("");
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        LoginIndication = new javax.swing.JSeparator();
        jLabel1 = new javax.swing.JLabel();
        UsernameField = new javax.swing.JTextField();
        LoginButton = new javax.swing.JButton();
        LogoutButton = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        TCP_Port = new javax.swing.JTextField();
        TCP_IP = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        AvailableInterfaces = new javax.swing.JComboBox<>();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        LocalIPField = new javax.swing.JTextField();
        LocalPortField = new javax.swing.JTextField();
        DestIPField = new javax.swing.JTextField();
        DestPortField = new javax.swing.JTextField();
        SendButton = new javax.swing.JButton();
        jLabel10 = new javax.swing.JLabel();
        Status = new javax.swing.JTextField();
        ClientNameLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        onlineUsers = new javax.swing.JList<>();
        Open = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        Files = new javax.swing.JList<>();
        jLabel11 = new javax.swing.JLabel();
        jSpinner1 = new javax.swing.JSpinner();
        RetransmissionsAndError = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Client Chat Application");
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        LoginIndication.setBackground(java.awt.Color.red);
        LoginIndication.setForeground(new java.awt.Color(179, 1, 30));

        jLabel1.setText("Username: ");

        LoginButton.setForeground(new java.awt.Color(0, 153, 51));
        LoginButton.setText("Login");
        LoginButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LoginHandler(evt);
            }
        });

        LogoutButton.setForeground(new java.awt.Color(179, 1, 30));
        LogoutButton.setText("Logout");
        LogoutButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LogoutHandler(evt);
            }
        });

        jLabel2.setText("TCP Server IP: ");

        jLabel3.setText("TCP Server Port: ");

        jLabel4.setText("Available Interfaces");

        AvailableInterfaces.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AvailableInterfacesActionPerformed(evt);
            }
        });

        jLabel5.setText("Online Users");

        jLabel6.setText("Local IP:");

        jLabel7.setText("Local Port:");

        jLabel8.setText("Remote IP:");

        jLabel9.setText("Remote Port:");

        SendButton.setFont(new java.awt.Font("Century Gothic", 1, 18)); // NOI18N
        SendButton.setText("SEND");
        SendButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TransmitHandler(evt);
            }
        });

        jLabel10.setText("Status:");

        Status.setEditable(false);

        ClientNameLabel.setFont(new java.awt.Font("Franklin Gothic Heavy", 0, 11)); // NOI18N
        ClientNameLabel.setToolTipText("");

        onlineUsers.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        onlineUsers.setFont(new java.awt.Font("Serif", 1, 18)); // NOI18N
        onlineUsers.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        onlineUsers.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                onlineUsersMousePressed(evt);
            }
        });
        jScrollPane1.setViewportView(onlineUsers);

        Open.setFont(new java.awt.Font("Century Gothic", 1, 18)); // NOI18N
        Open.setText("Open File");
        Open.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OpenActionPerformed(evt);
            }
        });

        Files.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        Files.setFont(new java.awt.Font("Agency FB", 1, 24)); // NOI18N
        Files.setForeground(new java.awt.Color(0, 0, 153));
        Files.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        Files.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                FilesMousePressed(evt);
            }
        });
        jScrollPane2.setViewportView(Files);

        jLabel11.setText("Error Rate:");

        jSpinner1.setModel(new javax.swing.SpinnerNumberModel(0, 0, 100, 5));
        jSpinner1.setToolTipText("");

        RetransmissionsAndError.setText("Retransmissions Number:");

        jTextField1.setEditable(false);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ClientNameLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(LoginIndication, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel10)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Status, javax.swing.GroupLayout.PREFERRED_SIZE, 382, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(RetransmissionsAndError)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField1))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(Open, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 331, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(UsernameField, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(LoginButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(LogoutButton)))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel4)
                            .addComponent(AvailableInterfaces, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel6)
                                    .addComponent(jLabel7)
                                    .addComponent(jLabel8))
                                .addGap(14, 14, 14)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(LocalPortField, javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(DestIPField)
                                    .addComponent(LocalIPField, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jLabel2))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(TCP_IP, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE)
                                    .addComponent(TCP_Port, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE)))
                            .addComponent(SendButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel9)
                                    .addComponent(jLabel11))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jSpinner1)
                                    .addComponent(DestPortField))))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 84, Short.MAX_VALUE)
                                .addComponent(jLabel5)
                                .addGap(55, 55, 55))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(22, 22, 22)
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(ClientNameLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(LoginIndication, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel1)
                                    .addComponent(UsernameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(LoginButton, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(LogoutButton, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jScrollPane2))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(26, 26, 26)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jLabel3)
                                            .addComponent(TCP_Port, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel2)
                                        .addComponent(TCP_IP, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(AvailableInterfaces, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel6)
                                    .addComponent(LocalIPField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel7)
                                    .addComponent(LocalPortField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel8)
                                    .addComponent(DestIPField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel9)
                                    .addComponent(DestPortField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel11)
                                    .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(0, 11, Short.MAX_VALUE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(Open, javax.swing.GroupLayout.PREFERRED_SIZE, 53, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(SendButton, javax.swing.GroupLayout.PREFERRED_SIZE, 53, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel10)
                    .addComponent(Status, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(RetransmissionsAndError)
                    .addComponent(jTextField1))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void LoginHandler(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LoginHandler
        
        if(!this.LoggedIn){
        this.ClientUsername = this.UsernameField.getText();
        if(this.ClientUsername.isEmpty()) JOptionPane.showMessageDialog(ClientChat_App.this,"Username needed!","Login Faild!", JOptionPane.ERROR_MESSAGE);
        else if(this.TCP_IP.getText().isEmpty() || this.TCP_Port.getText().isEmpty() )
            JOptionPane.showMessageDialog(ClientChat_App.this,"TCP IP and Port Number Are Needed!","Login Faild!", JOptionPane.ERROR_MESSAGE);
        else if(this.LocalIPField.getText().isEmpty() ||  this.LocalPortField.getText().isEmpty() )
                      JOptionPane.showMessageDialog(ClientChat_App.this,"Local IP Address And Local Port Number Both Needed!","Login Faild!", JOptionPane.ERROR_MESSAGE);   
        else{
            try {
            if(this.LocalPortField.getText().isEmpty())
                JOptionPane.showMessageDialog(ClientChat_App.this,"Local Port Number needed","Booking Port Faild!", JOptionPane.ERROR_MESSAGE);
            else{
            this.SrcIpAddress = InetAddress.getByName(this.LocalIPField.getText());
            this.SrcPortNumber = Integer.parseInt(this.LocalPortField.getText());   
            //UDP SOCKET AND RUNNING UDP RECEIVING THREAD
            this.clientSocket = new DatagramSocket(this.SrcPortNumber , this.SrcIpAddress);
            this.thread_on = true;
            
            
            //Now we have to connect to the TCP Server by Doing a TCP CLIENT SOCKET
            this.TCP_IPAddress = InetAddress.getByName(this.TCP_IP.getText());
            this.TCP_PortNumber = Integer.parseInt(this.TCP_Port.getText());
            //TCP CLIENT SOCKET
            //THIS Will Connect to the TCP SERVER & it will choose the SrcIpAddress and SrcPortNumber For the Socket Automatically
            this.ClientTCPSocket  = new Socket(this.TCP_IPAddress , this.TCP_PortNumber);
            //NOW FROM OUR TCP CLIENT SOCKET WE SEND THAT OUR INFO TO THE SERVER AS AN INDICATION THAT WE ARE ONLINE
            this.outToServer = new DataOutputStream(this.ClientTCPSocket.getOutputStream());
            this.Reader = new InputStreamReader(this.ClientTCPSocket.getInputStream());
            this.inFromServer = new BufferedReader(Reader);
            //RUNNING TCP THREAD.
            onlineUsersThread = new OnlineUsersThread("Online Receiving");
            onlineUsersThread.start();
            this.users_thread_on = true;
            
            //NOW we add to the server the client information to put it in Online Users List that is existed in  the Server side
            this.TCP_String = "A" + this.SrcIpAddress.getHostAddress()+" , " + this.SrcPortNumber;//A For "ADD"
            outToServer.writeBytes(this.TCP_String+"\n");
            
            this.LoggedIn = true;
            this.LoginIndication.setBackground(Color.green);
            this.LoginIndication.setForeground(new Color(0,153,51));
            this.ClientNameLabel.setText("User Logged in: "+this.ClientUsername);
            this.ClientNameLabel.setForeground(new Color(0,153,51));
            this.LoginButton.setForeground(new Color(0,153,51));
            this.LoginButton.setBackground(new Color(0,153,51));
            }
        } 
        catch (SocketException ex) { Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex); } 
        catch (IOException ex) { Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex); } 
            
        }
    }
        else{
            JOptionPane.showMessageDialog(ClientChat_App.this,"Already Logged in by: "+this.ClientUsername,"Login Faild!", JOptionPane.ERROR_MESSAGE);
        }
        
    }//GEN-LAST:event_LoginHandler

    private void LogoutHandler(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LogoutHandler
        // TODO add your handling code here:
        if(this.LoggedIn == true){
        this.LoggedIn = false;
        this.thread_on=false;
        this.users_thread_on = false;
        this.LoginIndication.setBackground(Color.RED);
        this.LoginIndication.setForeground( new Color(179,1,30) );
        this.ClientNameLabel.setText("");
        //WE CLOSE UDP SOCKET
        if(this.clientSocket != null ){
        this.clientSocket.close();
        }   
        //we got online and logged in , after that we gave our info to the server , after that the server replied , SO AFTER ALL THAT ==> the TCP socket  will be closed
        //ALSO WE WILL SEND HIM A MSG THAT WE ARE NOT ONLINE ANYMORE
            try {
                //WE MADE NEW CONNECTION , SO THAT WE CAN SEND THE INFO OF THE CLIENT WHO JUST LOGGED OUT
                this.ClientTCPSocket  = new Socket(this.TCP_IPAddress , this.TCP_PortNumber);
                this.outToServer = new DataOutputStream(this.ClientTCPSocket.getOutputStream());
                this.ClientInfoDelete = "D" + this.SrcIpAddress.getHostAddress() + " , "+this.SrcPortNumber; //D For "DELETE"
                outToServer.writeBytes(this.ClientInfoDelete+"\n");
                this.ClientTCPSocket.close();
            } catch (IOException ex) {
                Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
            }
            this.SrcPortNumber = 70000;
            this.ClientUsername = null;
            this.USERSLIST.clear();
            this.FILESLIST.clear();
            this.selectedFile = null;
    }
    }//GEN-LAST:event_LogoutHandler

    private void TransmitHandler(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TransmitHandler
        // TODO add your handling code here:
        if(!this.LoggedIn){ JOptionPane.showMessageDialog(ClientChat_App.this,"Login Needed!","Send Faild!", JOptionPane.ERROR_MESSAGE); }
        else if(this.SrcPortNumber==70000) JOptionPane.showMessageDialog(ClientChat_App.this,"Setting Port Needed!","Send Faild!", JOptionPane.ERROR_MESSAGE);
        else if(this.LocalIPField.getText().isEmpty() || this.DestIPField.getText().isEmpty() ||  this.LocalPortField.getText().isEmpty() || this.DestPortField.getText().isEmpty() ){
            JOptionPane.showMessageDialog(ClientChat_App.this,"All 4 Feilds with IP Addresses and Port Numbers are needed","Send Faild!", JOptionPane.ERROR_MESSAGE);
        }
        else if(this.selectedFile == null){
            JOptionPane.showMessageDialog(ClientChat_App.this,"No File Chosen!","Send Faild!", JOptionPane.ERROR_MESSAGE);
        }
        else if( Integer.parseInt(this.jSpinner1.getValue().toString()) >= 50 && (JOptionPane.showConfirmDialog(this,"You Have Chosen A Very High Error Rate => "+this.jSpinner1.getValue()+"%"+" \nAre You Sure You Want To Proceed ?","High Error Rate Warning!",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE)!= 0) ){
        }         
        else{
            
            try {
                this.SrcIpAddress = InetAddress.getByName(this.LocalIPField.getText());
                this.DestIpAddress = InetAddress.getByName(this.DestIPField.getText());
                this.SrcPortNumber = Integer.parseInt(this.LocalPortField.getText());
                this.DestPortNumber = Integer.parseInt(this.DestPortField.getText());
            } 
            catch (UnknownHostException ex) {Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);}
            this.thread_on = false;
            this.Sending = true;
            byte[] FileName = null;
            int FileSize = 0;
            byte[] FileNameSizePacket;
            byte[] bArrayFile = null;
            int NumberOfRetransmissions = 0;
            this.RetransmissionsAndError.setText("Number Of Retransmissions = ");
            this.jTextField1.setText(Integer.toString(NumberOfRetransmissions));
            //First We need to send the name of the File & SIZE
            try {
                //SEND THE PACKET WITH FULL NAME OF THE FILE AND THE FILE LENGTH (SIZE)
                FileName = this.selectedFile.getName().getBytes();
                bArrayFile = readFileToByteArray(this.selectedFile);
                FileSize = bArrayFile.length;
                Packet packet = new Packet();
                packet.setFileSize(FileSize);
                packet.addData(FileName, FileName.length);
                ByteBuffer byteBuf = packet.toByteBuffer();
                FileNameSizePacket = byteBuf.array();
                DatagramPacket sendPacket = new DatagramPacket(FileNameSizePacket , FileNameSizePacket.length , this.DestIpAddress , this.DestPortNumber);
                clientSocket.send(sendPacket);
                System.out.println("File Name : "+new String(FileName) );
                System.out.println("\tSize : "+FileSize );
            }
            catch (IOException ex) { Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex); }

            
            int randomNum = this.generator.nextInt(101);
            double errorRate =  ( Double.parseDouble(this.jSpinner1.getValue().toString()) )/100;
            double bound = errorRate*100;
            boolean sendWithError = ( randomNum < bound );
            
            System.out.println("Sending File...");
            int sequenceNumber = 0; // For order
            boolean LastPacket; // To see if we got to the end of the file
            int ackSequence = 0; // To see if the datagram was received correctly
            boolean onePacket = false;
            Packet packetToSend = new Packet(); 
            byte[] arrayToSend;
            byte[] dataChunk = new byte[1024];
            for (int i = 0; i < FileSize ; i+=1024) {
                try {
                    sequenceNumber++;
                    packetToSend.setSeqControl( (byte) (sequenceNumber >> 8) );
                    packetToSend.setSeqNumber( (byte) (sequenceNumber) );
                    
                    if ((i + 1024) >= FileSize) { // LAST PACKET
                        LastPacket = true;
                        packetToSend.setLastPacket((byte) (1)); 
                    } else {
                        LastPacket = false;
                        packetToSend.setLastPacket((byte) (0));
                    }
                    
                    if (!LastPacket) {
                        System.arraycopy(bArrayFile , i , dataChunk , 0 , 1024);
                    } else { 
                        System.arraycopy(bArrayFile, i, dataChunk, 0, FileSize - i);
                    }
                    
                    
                    packetToSend.addData(dataChunk , dataChunk.length);
                    packetToSend.setChecksum();
                    int GeneretedCkecksum = this.CRC_generator(packetToSend.getChecksum());
                    
                    //WE CHECK IF WE NEED TO SEND WITH ERRORS , WE CHANGE THE CHECKSUM AND ADD AN ERROR TO IT BY DOING 1's Compelement THEN ADD THE RANDOM NUMBER TO IT
                    if(sendWithError)
                        packetToSend.set_Generated_Checksum(GeneretedCkecksum - randomNum + this.generator.nextInt(222) );
                    else 
                        packetToSend.set_Generated_Checksum(GeneretedCkecksum);
                    
                    ByteBuffer PacketToSendBuf = packetToSend.toByteBuffer();
                    arrayToSend = PacketToSendBuf.array();
                    DatagramPacket sendPacket = new DatagramPacket(arrayToSend , arrayToSend.length , this.DestIpAddress , this.DestPortNumber); 
                    clientSocket.send(sendPacket); 
                    System.out.println("Sent: Packet With Seq# = " + sequenceNumber+" || Checksum = "+packetToSend.getChecksum() );
                    
                    
                    onePacket = (FileSize<=1024);
                    if(onePacket) {
                        System.out.println("One Packet Sent");
                        System.out.println("******************************************************************");
                        System.out.println("##################################################################");
                    }
                    
                    
                    boolean ackReceived;
                    while (true && !onePacket) {
                        byte[] ack = new byte[ HEADER_LENGTH + MAX_DATA_LENGTH ];
                        DatagramPacket ackPacket = new DatagramPacket(ack, ack.length);
                        Packet receiveAckPacket = new Packet();
                        ByteBuffer rcvAckBuf;
                        try {
                            clientSocket.setSoTimeout(100); 
                            clientSocket.receive(ackPacket);
                            rcvAckBuf = ByteBuffer.wrap(ackPacket.getData());      
                            receiveAckPacket.extractPacketfromByteBuffer(rcvAckBuf);
                            
                            ackSequence = ((receiveAckPacket.getSeqControl() & 0xff) << 8) + (receiveAckPacket.getSeqNumber() & 0xff);
                            ackReceived = true;
                        } catch (SocketTimeoutException e) {
                            System.out.println("Socket Timed Out => Reseinding...");
                            ackReceived = false;
                        }
                        //IF THE ACK PACKET = SEQ NUMBER ||| AND THE ACK ALREADY RECEIVED ||| AND THE RECEIVED ACK PACKET HAS NO ERROR IN THE CHECKSUM THEN WE STOP WAITING FOR ACK
                        if ((ackSequence == sequenceNumber) && (ackReceived) && (CRC_Detection(receiveAckPacket) == false) ) {
                            System.out.println("Received Ack: Packet With Seq# = " + ackSequence + " || Checksum = "+receiveAckPacket.getChecksum());
                            System.out.println("******************************************************************");
                            break;
                        }
                        
                        else {
                            clientSocket.send(sendPacket);
                            ++NumberOfRetransmissions;
                            //AFTER HUGE NUMBER OF RETRANSMATIONS BECAUSE OF THE HIGH ERROR RATE , WE WILL FIGURE OUT THAT IT WILL NOT END
                            //SO ALL I DID IS BREAK FROM LOOP
                            if(NumberOfRetransmissions>9999) break;
                            this.RetransmissionsAndError.setText("Number Of Retransmissions = ");
                            this.jTextField1.setText(Integer.toString(NumberOfRetransmissions));
                            System.out.println("Resending: Packet With Seq# = " + sequenceNumber);
                        }       
                }
            }
            catch (IOException ex) {
                    Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
                }
        }           
                if(!onePacket) System.out.println("##################################################################");
                Status.setText("Sent To: IP="+DestIpAddress.getHostAddress()+" ,"+"Port="+DestPortNumber); 
                this.SendButton.setForeground(new Color(0,153,51));
                this.SendButton.setBackground(new Color(0,153,51));
                this.startSendAnimation = true;
                
            try {
                this.clientSocket.setSoTimeout(0);
            } catch (SocketException ex) {
                Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
            }
            this.Sending = false;
            this.thread_on = true; 
            
            //EXTRACT THE EXTENSTION
            String FileExtension=null;
            int index = new String(FileName).lastIndexOf('.');
                if(index > 0) {
                    FileExtension = new String(FileName).substring(index + 1);
                }                           
            MyFile FileReceived = new MyFile(FileSentID , new String(FileName)  , FileExtension ,  bArrayFile , FileSize);
            FileSentID++;
            SentFiles.add(FileSentIndex , FileReceived);
            FileSentIndex++;
            FILESLIST.addElement("SENT => " + FileReceived.getID() + " - " +FileReceived.getName() + " , " + FileReceived.getFileFileSize()+" Bytes");                                        
	}      
    }//GEN-LAST:event_TransmitHandler

    private void AvailableInterfacesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AvailableInterfacesActionPerformed
        // TODO add your handling code here:
            String S[] = this.AvailableInterfaces.getSelectedItem().toString().split(": ");
            this.LocalIPField.setText(S[1]);
    }//GEN-LAST:event_AvailableInterfacesActionPerformed

    private void onlineUsersMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_onlineUsersMousePressed
        // TODO add your handling code here:
        String A;
        String tokens[];
        int i = onlineUsers.getSelectedIndex();
        if(i!=-1){
        A = USERSLIST.getElementAt(i).toString();
        tokens = A.split(" , ");
        this.DestIPField.setText(tokens[0]);
        this.DestPortField.setText(tokens[1]);
        }
    }//GEN-LAST:event_onlineUsersMousePressed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if(this.LoggedIn == true){
        this.LoggedIn = false;
        this.thread_on=false;
        this.users_thread_on = false;
        this.LoginIndication.setBackground(Color.RED);
        this.LoginIndication.setForeground( new Color(179,1,30) );
        this.ClientNameLabel.setText("");
        //WE CLOSE UDP SOCKET
        if(this.clientSocket != null ){
        this.clientSocket.close();
        }   
        //we got online and logged in , after that we gave our info to the server , after that the server replied , SO AFTER ALL THAT ==> the TCP socket  will be closed
        //ALSO WE WILL SEND HIM A MSG THAT WE ARE NOT ONLINE ANYMORE
            try {
                //WE MADE NEW CONNECTION , SO THAT WE CAN SEND THE INFO OF THE CLIENT WHO JUST LOGGED OUT
                this.ClientTCPSocket  = new Socket(this.TCP_IPAddress , this.TCP_PortNumber);
                this.outToServer = new DataOutputStream(this.ClientTCPSocket.getOutputStream());
                this.ClientInfoDelete = "D" + this.SrcIpAddress.getHostAddress() + " , "+this.SrcPortNumber; //D For "DELETE"
                outToServer.writeBytes(this.ClientInfoDelete+"\n");
                this.ClientTCPSocket.close();
            } catch (IOException ex) {
                Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
            }
            this.SrcPortNumber = 70000;
            this.ClientUsername = null;
            this.USERSLIST.clear();
    }
    }//GEN-LAST:event_formWindowClosing

    private void OpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OpenActionPerformed
        // TODO add your handling code here:
        if(this.LoggedIn){
        int r = fileChooser.showOpenDialog(this);
        if(r == JFileChooser.APPROVE_OPTION) { 
            this.selectedFile = fileChooser.getSelectedFile();
            this.Open.setForeground(new Color(0,153,51));
            this.Open.setBackground(new Color(0,153,51));
            this.startAnimation = true;
        }  
    } 
        else JOptionPane.showMessageDialog(ClientChat_App.this,"Login Needed!","Browsing File Faild!", JOptionPane.ERROR_MESSAGE);
    }//GEN-LAST:event_OpenActionPerformed

    private void FilesMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_FilesMousePressed
        // TODO add your handling code here:
        String A;
        String tokens[];
        int i = Files.getSelectedIndex();
        if(i!=-1){
        A = FILESLIST.getElementAt(i).toString();
        boolean SENT = ( A.contains("SENT => ") );
        if(SENT){
            A = A.substring(8);
            tokens = A.split(" , ");
            String ID[] = A.split(" - ");
            if(JOptionPane.showConfirmDialog(this,"ReDownload => "+ID[1],"ReDownload Permission" ,JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE)==0){
                int option = DIRECTORYChooser.showOpenDialog(this);
            
                if(option == JFileChooser.APPROVE_OPTION){
                    File file = DIRECTORYChooser.getSelectedFile();
                
                    for(MyFile myfile : this.SentFiles){
                        if(myfile.getID() == Integer.parseInt(ID[0])){
                            File f = new File (file.getAbsolutePath() + "\\" + myfile.getName()); 
                            FileOutputStream outToFile;
                            try {
                                outToFile = new FileOutputStream(f);
                                outToFile.write(myfile.getData());
                                outToFile.close();
                            } catch (FileNotFoundException ex) {
                                Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
                            } catch (IOException ex) {
                                Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            break;
                        }
                    }
                }
        }  
    }
        else{           
        tokens = A.split(" , ");
        String ID[] = A.split(" - ");
        if(JOptionPane.showConfirmDialog(this,"Download => "+ID[1],"Download Permission" ,JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE)==0){
            int option = DIRECTORYChooser.showOpenDialog(this);
            
                if(option == JFileChooser.APPROVE_OPTION){
                    File file = DIRECTORYChooser.getSelectedFile();
                
                    for(MyFile myfile : this.AllFiles){
                        if(myfile.getID() == Integer.parseInt(ID[0])){
                            File f = new File (file.getAbsolutePath() + "\\" + myfile.getName()); 
                            FileOutputStream outToFile;
                            try {
                                outToFile = new FileOutputStream(f);
                                outToFile.write(myfile.getData());
                                outToFile.close();
                            } catch (FileNotFoundException ex) {
                                Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
                            } catch (IOException ex) {
                                Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            break;
                        }
                    }
                }
        }
        }
    }
        
    }//GEN-LAST:event_FilesMousePressed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ClientChat_App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ClientChat_App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ClientChat_App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ClientChat_App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new ClientChat_App().setVisible(true);
            }
        });
    }
    
    //This is the receiver thread , it will be on when only when we book a port number for out appliction
    //So when we book a port number our app will be ready to receive any msg
    //the receiver thread itself starts from ClientChat_App constructer , but it will now receive anything bacause it's technacly off because of the boolean thread_on = false
    //it will become true only when we book the port number
    //that will help us to book another port number when we close the socket (when we press close button)
    //if we don't use a flage the application will stop because of a run time error , you can't call function start more than once in threads
    	class ReceivingThread extends Thread { 
                int FileID = 1;
                String ReceivedMSG = "";
                String FileName;
                String FileExtension;
                int FileLength;
                String IP;
                int seq = 0;
                InetAddress SrcAckIpAddress;
                int DestAckPortNumber; 
                boolean nameReceived;
                InetAddress address;
                int port;
                
		public ReceivingThread() {
		}
		public ReceivingThread(String name) {
			super(name);
		}
                private void sendAck(int Checksum , int foundLast , DatagramSocket socket , InetAddress address , int port) throws IOException {
                // send acknowledgement
                byte[] AckArrayToSend;
                Packet ackPacket = new Packet();
                ackPacket.set_Generated_Checksum(Checksum);
                ackPacket.setSeqControl((byte) (foundLast >> 8));
                ackPacket.setSeqNumber((byte) (foundLast));
                ByteBuffer AckPacketBuf = ackPacket.toByteBuffer();
                AckArrayToSend = AckPacketBuf.array();
                DatagramPacket acknowledgement = new DatagramPacket(AckArrayToSend , AckArrayToSend.length , address , port);
                socket.send(acknowledgement);
                System.out.println("Sent Ack: Packet With Seq# = " + foundLast + " || Checksum = "+ ackPacket.getChecksum() );
                }
		@Override
		public void run() {
                            while(true){
                                  try{
                                    Thread.sleep(0);
                                    if(thread_on){
                                        //WE RECEIVE THE FILE NAME , AND THE FILE EXTENSION  
                                        int countOfErrors = 0;
                                        for(int i=0;i<receiveData.length;i++) receiveData[i]=0; //WE NEED TO EMPTY THE ARRAY TO HAVE NEW DATA RECEIVED IN IT
                                        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);//we do a a receive packet
                                        clientSocket.receive(receivePacket); // now we receive the packet
                                        if(Sending){ continue; }
                                        ByteBuffer rcvFileInfoBuf = ByteBuffer.wrap(receivePacket.getData());
                                        Packet rcvPacket = new Packet();
                                        rcvPacket.extractPacketfromByteBuffer(rcvFileInfoBuf);
                                        FileName = (new String(rcvPacket.getData())) ; // we extract the NAME.EX from the packet
                                        FileLength = rcvPacket.getFileSize();   
                                        if( FileLength==0 ){ continue; }
                                        System.out.println("File Name : "+FileName);
                                        System.out.println("\tSize : "+FileLength);

                                        //EXTRACT THE EXTENSTION
                                        int index = FileName.lastIndexOf('.');
                                        if(index > 0) {
                                                FileExtension = FileName.substring(index + 1);
                                        }
                                        
                                        System.out.println("Receiving File...");
                                        
                                        boolean LastPacket;
                                        int i = 0;
                                        int sequenceNumber = 0; // Order of sequences
                                        int foundLast = 0; // The las sequence found
                                        byte[] AllData = new byte[FileLength];
                                        
                                        //IF THE FILE IS ONE PACKET , 1024 BYTE OR LESS THAN 1024 BYTE THEN WE RECEIVE ONE PACKET
                                        RetransmissionsAndError.setText("Number Of Errors = ");
                                        jTextField1.setText(Integer.toString(countOfErrors));
                                        while (true) {
                                            byte[] PacketArrayReceived = new byte[ HEADER_LENGTH + MAX_DATA_LENGTH ];
                                            byte[] Data;

                                            DatagramPacket receivedPacket = new DatagramPacket(PacketArrayReceived, PacketArrayReceived.length);
                                            clientSocket.receive(receivedPacket);
                                            ByteBuffer FileDataBuf = ByteBuffer.wrap(receivedPacket.getData());
                                            Packet PacketReceived = new Packet();
                                            PacketReceived.extractPacketfromByteBuffer(FileDataBuf);
                                            Data = PacketReceived.getData();
                                            
                                            // Get port and address for sending ack
                                            address = receivedPacket.getAddress();
                                            port = receivedPacket.getPort();

                                            sequenceNumber = ((PacketReceived.getSeqControl() & 0xff) << 8) + (PacketReceived.getSeqNumber() & 0xff);
                                            LastPacket = (PacketReceived.getLastPacket() & 0xff) == 1;
            
                                            // If sequence number is the last seen + 1, then it is correct
                                            // We get the data from the message and write the ack that it has been received correctly
                                            if ( (sequenceNumber == (foundLast + 1)) && (CRC_Detection(PacketReceived) == false) ) {
                                                foundLast = sequenceNumber;
                                                if(!LastPacket){
                                                    System.arraycopy(Data , 0 , AllData , i , 1024);
                                                    i+=1024;
                                                }
                                                else if(LastPacket) {
                                                    System.arraycopy(Data , 0 , AllData , i , FileLength - i );
                                                }
                                                System.out.println("Received: Packet With Seq# = "  + foundLast +" || Checksum = " + PacketReceived.getChecksum());  
                                                sendAck(PacketReceived.getChecksum() , foundLast , clientSocket , address , port);
                                                if(LastPacket) {break;}
                                            } else {
                                                countOfErrors++;
                                                if(countOfErrors>9999)break;
                                                RetransmissionsAndError.setText("Number Of Errors = ");
                                                jTextField1.setText(Integer.toString(countOfErrors));
                                                System.out.println("Expected Seq# = " + (foundLast + 1) + " || BUT Received Seq#=" + sequenceNumber + " Checksum=" + PacketReceived.getChecksum() +" --**IGNORED");
                                                sendAck(PacketReceived.getChecksum() , foundLast , clientSocket , address , port);
                                            }
                                            System.out.println("******************************************************************");
                                        }
   
                                        System.out.println("##################################################################");
                                        //NOW WE HAVE ALL THE INFO ABOUT THE FILE =>> NAME , EXTENSION , DATA , SIZE
                                        //WE NEED TO ADD THE DO AN OBJECT OF THE FILE , AND ADD IT TO THE FILE LIST
                                        MyFile FileReceived = new MyFile(FileID , FileName , FileExtension ,  AllData , FileLength);
                                        FileID++;
                                        AllFiles.add(FileArrayListIndex , FileReceived);
                                        FileArrayListIndex++;
                                        FILESLIST.addElement(FileReceived.getID() + " - " +FileReceived.getName() + " , " + FileReceived.getFileFileSize()+" Bytes");                                        
                                        Status.setText("Received From: IP="+address.getHostAddress()+" ,"+"Port="+port);       
                                    }
                                    
                                }
                        catch (IOException ex) { System.out.println("socket closed"); } 
                        catch (InterruptedException ex) { Logger.getLogger(ClientChat_App.class.getName()).log(Level.SEVERE, null, ex); }
                        catch (NumberFormatException ex) { System.out.println("THERE IS AN ERROR WITH SENDING!"); }           
                    }   
            }       
	}
	
        //TCP CLIENT
    	class OnlineUsersThread extends Thread {  
            String OnlineUser;
            char Process;
		public OnlineUsersThread() {
		}
		public OnlineUsersThread(String name) {
			super(name);
		}
		@Override
		public void run() {
                            while(true){
                                  try{
                                    Thread.sleep(0);
                                    if(users_thread_on){
                                        OnlineUser = inFromServer.readLine();
                                        Process = OnlineUser.charAt(0);
                                        if( OnlineUser.charAt(0) == 'D'){
                                            OnlineUser = OnlineUser.substring(1);
                                            if( USERSLIST.contains(OnlineUser) ){
                                                USERSLIST.removeElement(OnlineUser);
                                            }
                                        }        
                                        else if( !USERSLIST.contains(OnlineUser) ){
                                            USERSLIST.addElement(OnlineUser);
                                        }
                                    }
                                }
                        catch ( InterruptedException | IOException ex) {  System.out.println(ex.toString()); }           
                    }       
            }
  }

    	class Animation extends Thread {  
		public Animation() {
		}
		public Animation(String name) {
			super(name);
		}
		@Override
		public void run() {
                            while(true){
                                  try{
                                        Thread.sleep(0);
                                        if(startAnimation){
                                            for(int i=152 ; i>=0 ; i-=3){
                                                Thread.sleep(80);
                                                Open.setForeground(new Color(0,i,0));
                                                Open.setBackground(new Color(240,240,240));
                                            }
                                            startAnimation = false;
                                        }
                                }
                        catch ( InterruptedException ex) {  System.out.println(ex.toString()); }           
                    }       
            }
  }
        
            	class SendButtonAnimation extends Thread {  
		public SendButtonAnimation() {
		}
		public SendButtonAnimation(String name) {
			super(name);
		}
		@Override
		public void run() {
                            while(true){
                                  try{
                                        Thread.sleep(0);
                                        if(startSendAnimation){
                                            for(int i=152 ; i>=0 ; i-=3){
                                                Thread.sleep(80);
                                                SendButton.setForeground(new Color(0,i,0));
                                                SendButton.setBackground(new Color(240,240,240));
                                            }
                                            startSendAnimation = false;
                                        }
                                }
                        catch ( InterruptedException ex) {  System.out.println(ex.toString()); }           
                    }       
            }
  }
        
        //this function allows us to add text into the JTextPane and also with changing the color 
        //so we can add a line of text with specefic color that we want
        private void appendWithColor(JTextPane tp, String msg, Color c){
        StyleContext sc = StyleContext.getDefaultStyleContext();
        AttributeSet aset = sc.addAttribute(SimpleAttributeSet.EMPTY, StyleConstants.Foreground, c);

        aset = sc.addAttribute(aset, StyleConstants.FontFamily, "Times New Roman");
        aset = sc.addAttribute(aset, StyleConstants.Alignment, StyleConstants.ALIGN_JUSTIFIED);

        int len = tp.getDocument().getLength();
        tp.setCaretPosition(len);
        tp.setCharacterAttributes(aset, false);
        tp.replaceSelection(msg);
        }
        
        
          
        private static byte[] readFileToByteArray(File file) {
            FileInputStream fis = null;
            byte[] bArray = new byte[(int) file.length()];
            try {
                fis = new FileInputStream(file);
                fis.read(bArray);
                fis.close();
            } catch (IOException ioExp) { System.out.println(ioExp.toString()); }
            return bArray;
    }
    
    //THIS FUNCTION MAKE DETECTION ERROR
    private boolean CRC_Detection(Packet receiveAckPacket) {
        
        String Ckecksum = Integer.toBinaryString( receiveAckPacket.getChecksum() );
        String CRC_Generator = ClientChat_App.CRC_16;
        
        
        int [] ReceiverData = new int[ Ckecksum.length() + CRC_Generator.length() - 1];
        int [] divisor = new int[CRC_Generator.length()];

        
        for (int i = 0; i < Ckecksum.length() ; i++) {
            ReceiverData[i] = Integer.parseInt(Ckecksum.charAt(i) + "");
        }

        
        for (int i = 0; i < CRC_Generator.length() ; i++) {
            divisor[i] = Integer.parseInt(CRC_Generator.charAt(i) + "");
        }

        
        // Calculation Of Remainder
        for (int i = 0; i < Ckecksum.length() ; i++) {
            if (ReceiverData[i] == 1) {
                for (int j = 0; j < divisor.length; j++) {
                    ReceiverData[i + j] ^= divisor[j];
                }
            }
        }
        // Display The ERROR Check
        boolean error = false;
        for (int i = 0; i < ReceiverData.length; i++) {
            if (ReceiverData[i] == 1) {
                error = true;
                break;
            }
        }
        return error;
    }
    
    private int CRC_generator(int checksum) {   
          
        String CRC_generator = ClientChat_App.CRC_16;       //WE Take The Generator Wich Is The Pattern
        String GeneratedChecksum = Integer.toBinaryString(checksum);  //WE Take The Checksum We Need To GENERATE
        
        int []data = new int[ GeneratedChecksum.length() + CRC_generator.length() - 1];	
	int []divisor = new int[ CRC_generator.length() ];
        
        for (int i = 0; i < GeneratedChecksum.length() ; i++) {
            data[i] = Integer.parseInt(GeneratedChecksum.charAt(i) + "");
        }

        for (int i = 0; i < GeneratedChecksum.length() ; i++) {
            data[i] = Integer.parseInt(GeneratedChecksum.charAt(i) + "");
        }
  
        for (int i = 0; i < CRC_generator.length() ; i++) {
            divisor[i] = Integer.parseInt(CRC_generator.charAt(i) + "");
        }


        // Calculation of Rem
        for (int i = 0; i < GeneratedChecksum.length() ; i++) {
            if (data[i] == 1) {
                for (int j = 0; j < divisor.length ; j++) {
                    data[i + j] ^= divisor[j];             // XoR Between Each Digit Of The Data And Divisor
                }
            }
        }

        for (int i = 0; i < GeneratedChecksum.length() ; i++) {
            data[i] = Integer.parseInt(GeneratedChecksum.charAt(i) + "");
        }
        
        String CRC_Generated_Data = "";
        for (int i = 0; i < data.length ; i++){
            CRC_Generated_Data += data[i];
        }
        
        return (Integer.parseInt(CRC_Generated_Data, 2));    
        
    }   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> AvailableInterfaces;
    private javax.swing.JLabel ClientNameLabel;
    private javax.swing.JTextField DestIPField;
    private javax.swing.JTextField DestPortField;
    private javax.swing.JList<String> Files;
    private javax.swing.JTextField LocalIPField;
    private javax.swing.JTextField LocalPortField;
    private javax.swing.JButton LoginButton;
    private javax.swing.JSeparator LoginIndication;
    private javax.swing.JButton LogoutButton;
    private javax.swing.JButton Open;
    private javax.swing.JLabel RetransmissionsAndError;
    private javax.swing.JButton SendButton;
    private javax.swing.JTextField Status;
    private javax.swing.JTextField TCP_IP;
    private javax.swing.JTextField TCP_Port;
    private javax.swing.JTextField UsernameField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSpinner jSpinner1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JList<String> onlineUsers;
    // End of variables declaration//GEN-END:variables
}